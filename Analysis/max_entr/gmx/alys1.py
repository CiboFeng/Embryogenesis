import numpy as np
from scipy.io import loadmat
import matplotlib.pyplot as plt
from matplotlib import colors
from scipy.spatial.distance import pdist, squareform
from matplotlib.colors import LinearSegmentedColormap
import sys
sys.path.append('D:\Biophysics\MyPython\\functions')
from pdbs import pdbs
import sys
sys.path.append('/hpc2hdd/home/cfeng593/proj/mypython/functions')
sys.path.append('D:\Biophysics\MyPython\\functions')
from tot_len import tot_len
from trj import trj
from pdbs import pdbs
from pyw import pyw

"""Write .gro Files according to Chu's"""
# sysname = '1ubq'
# for i in range(100):
#     igro=f'D:\\GoogleChromeDownload\\PDB\\PDB\\N{i}.gro'
#     f = open(igro)
#     lsf = f.readlines()
#     f.close()
#     ls_f = []
#     for lf in lsf:
#         l_f = lf.strip('\n').split()
#         ls_f.append(l_f)
#     boundary=ls_f[len(ls_f)-1]
#     x=[]
#     y=[]
#     z=[]
#     for j in range(len(ls_f)):
#         if len(ls_f[j])>1 and ls_f[j][1]=='CA':
#             x += [float(ls_f[j][3])]
#             y += [float(ls_f[j][4])]
#             z += [float(ls_f[j][5])]
#     N=len(x)
#     dat=open(f'D:\Biophysics\MyPython\\applications\\max_entr_gmx\\grofiles_chu\\{sysname}_{i+1}.gro','w')
#     dat.write('Generated by trjconv : Protein t= 1500.00000\n')
#     dat.write(f'{N}\n')
#     for j in range(N):
#         if j+1<10:
#             dat.write(f'    {j+1}GLY     CA    {j+1}   {tot_len(x[j],4)}   {tot_len(y[j],4)}   {tot_len(z[j],4)}\n')
#         if j+1>=10 and j+1<100:
#             dat.write(f'   {j+1}GLY     CA   {j+1}   {tot_len(x[j],4)}   {tot_len(y[j],4)}   {tot_len(z[j],4)}\n')
#         if j+1>=100 and j+1<1000:
#             dat.write(f'  {j+1}GLY     CA  {j+1}   {tot_len(x[j],4)}   {tot_len(y[j],4)}   {tot_len(z[j],4)}\n')
#     dat.write(f'{boundary[0]} {boundary[1]} {boundary[2]}')
#     dat.close()

"""Bond Distance Range"""
# t,x,y,z=pdbs("C:\\Users\\18301\\Desktop\\1ubq_1.pdb")
# bond=[]
# lim=[]
# for i in range(len(t)):
#     bond.append([])
#     lim.append([])
#     for j in range(len(x[0])-1):
#         bond[i]+=[((x[i][j+1]-x[i][j])**2+(y[i][j+1]-y[i][j])**2+(z[i][j+1]-z[i][j])**2)**0.5]
#     lim[i]+=[min(bond[i])]
#     lim[i]+=[max(bond[i])]
# print('Shortest Bond:',np.min(np.array(lim)[:,0]))
# print('Longest Bond:',np.max(np.array(lim)[:,1]))
# # x=np.linspace(1,len(t),len(t))
# plt.plot(t,np.array(lim)[:,0],'.')
# plt.plot(t,np.array(lim)[:,1],'.')
# # plt.xlim(249,len(t)+1)
# plt.show()

"""Bond Distance Range"""
# bond=[]
# lim=[]
# for i in range(1):
#     igro = f'D:\Biophysics\MyPython\\applications\\max_entr_gmx\\grofiles_rand\\1ubq_{i+1}.gro'
#     igro = "D:\\GoogleChromeDownload\\N0.gro"
#     f = open(igro)
#     lsf = f.readlines()
#     f.close()
#     ls_f = []
#     for lf in lsf:
#         l_f = lf.strip('\n').split()
#         ls_f.append(l_f)
#     boundary = ls_f[len(ls_f) - 1]
#     x = []
#     y = []
#     z = []
#     for j in range(len(ls_f)):
#         if len(ls_f[j]) > 1 and ls_f[j][1] == 'CA':
#             x += [float(ls_f[j][3])]
#             y += [float(ls_f[j][4])]
#             z += [float(ls_f[j][5])]
#     bond.append([])
#     lim.append([])
#     for j in range(len(x) - 1):
#         bond[i] += [((x[j + 1] - x[j]) ** 2 + (y[j + 1] - y[j]) ** 2 + (z[j + 1] - z[j]) ** 2) ** 0.5]
#     lim[i] += [min(bond[i])]
#     lim[i] += [max(bond[i])]
# # x=np.linspace(1,100,100)
# # plt.plot(x,np.array(lim)[:,0],'.')
# # plt.plot(x,np.array(lim)[:,1],'.')
# # plt.xlim(249,len(t)+1)
# # plt.show()
# print(lim)

"""Distance Matrix"""
# lim=[]
# for i in range(100):
#     igro = f'D:\Biophysics\MyPython\\applications\\max_entr_gmx\\grofiles_rand\\1ubq_{i+1}.gro'
#     # igro=f"D:\\GoogleChromeDownload\\N{i}.gro"
#     f = open(igro)
#     lsf = f.readlines()
#     f.close()
#     ls_f = []
#     for lf in lsf:
#         l_f = lf.strip('\n').split()
#         ls_f.append(l_f)
#     boundary = ls_f[len(ls_f) - 1]
#     x = []
#     y = []
#     z = []
#     for j in range(len(ls_f)):
#         if len(ls_f[j]) > 1 and ls_f[j][1] == 'CA':
#             x += [float(ls_f[j][3])]
#             y += [float(ls_f[j][4])]
#             z += [float(ls_f[j][5])]
#     X=np.zeros((len(x),3))
#     X[:,0]=np.array(x)
#     X[:,1] = np.array(y)
#     X[:,2] = np.array(z)
#     D = squareform(pdist(X,'euclidean'))
#     Dplus=np.eye(len(D))*np.mean(D)
#     D+=Dplus
#     # print(f'{i}-th structure',np.argwhere(D < 0.05))
#     lim.append([])
#     lim[i] += [np.min(D)]
#     lim[i] += [np.max(D)]
# x=np.linspace(1,100,100)
# plt.plot(x,np.array(lim)[:,0],'.')
# plt.plot(x,np.array(lim)[:,1],'.')
# # plt.xlim(249,len(t)+1)
# plt.show()
# print(np.min(np.array(lim)[:,0]))

"""Maximum Distance to Mass Center"""
# rmax=[]
# # t,x,y,z=trj('400_1.trj')
# t,x,y,z=pdbs('trajout0.pdb')
# r=[]
# d=[]
# for i in range(len(x)):
#     r.append([])
#     xc=np.mean(x[i])
#     yc=np.mean(y[i])
#     zc=np.mean(z[i])
#     for j in range(len(x[0])):
#         r[i]+=[((xc-x[i][j])**2+(yc-y[i][j])**2+(zc-z[i][j])**2)**0.5]
#     for j in range(len(x[0])-1):
#         d+=[((x[i][j+1]-x[i][j])**2+(y[i][j+1]-y[i][j])**2+(z[i][j+1]-z[i][j])**2)**0.5]
#     rmax+=[max(r[i])]
# dmean=np.mean(d)
# dstd=np.std(d)
# print(dmean,dstd)
# t=np.linspace(1,len(x),len(x))
# plt.plot(t,rmax)
# # plt.plot(t,rmax,'.')
# # plt.plot(x0,rmax0)
# plt.show()

"""Alf"""
f=open('Contact_a_1.dat')
lsf=f.readlines()
f.close()
ls_f=[]
for lf in lsf:
    l_f=lf.strip('\n').split()
    ls_f.append(l_f)
ls_f=[list(map(float,sublist)) for sublist in ls_f]
N=int(ls_f[len(ls_f)-1][1])
Alf1=np.zeros((N,N),dtype=float)
for i in range(len(ls_f)):
    #if len(ls_f[i])>0: #In order to make sure the list index in next line does not exceed the range.
    Alf1[int(ls_f[i][0])-1,int(ls_f[i][1])-1]=ls_f[i][2]*100
    Alf1[int(ls_f[i][1])-1,int(ls_f[i][0])-1]=ls_f[i][2]*100
alf1=[]
for i in range(N):
    for j in range(N):
        alf1+=[Alf1[i][j]]
alf2=pyw('alf_400.pyw','Alpha')[0]
Alf2=np.zeros((N,N),dtype=float)
for i in range(N):
    for j in range(N):
        Alf2[i,j]=alf2[i*N+j]
Dlt=np.zeros((N,N),dtype=float)
for i in range(N):
    for j in range(N):
        if Alf1[i,j]+Alf2[i,j]!=0.0:
            Dlt[i,j]=(Alf1[i,j]-Alf2[i,j])/(Alf1[i,j]+Alf2[i,j])
plt.figure()
color=[(1,1,1),(1,0,0),(0,0,0)]
nodes=[0.0,0.5,1.0]
cmap=LinearSegmentedColormap.from_list('custom_cmap',list(zip(nodes,color)))
norm=colors.LogNorm()
plt.imshow(Dlt,cmap=cmap,norm=norm)
plt.gca().invert_yaxis()
plt.xlabel('Index of particles')
plt.ylabel('Index of particles')
plt.colorbar()
plt.show()

plt.figure()
dlt=[]
for i in range(N):
    for j in range(N):
        dlt+=[Dlt[i][j]]
plt.hist(dlt, bins=100, alpha=0.7, color='b')
plt.ylim(0,10)
plt.show()

plt.figure()
plt.plot(alf1,alf2,'.')
plt.show()

"""Probability"""
# f=open('Probability.dat')
# lsf=f.readlines()
# f.close()
# ls_f=[]
# for lf in lsf:
#     l_f=lf.strip('\n').split()
#     ls_f.append(l_f)
# ls_f=[list(map(float,sublist)) for sublist in ls_f]
# N=int(ls_f[len(ls_f)-1][1])
# P1=np.zeros((N,N),dtype=float)
# for i in range(len(ls_f)):
#     #if len(ls_f[i])>0: #In order to make sure the list index in next line does not exceed the range.
#     P1[int(ls_f[i][0])-1,int(ls_f[i][1])-1]=ls_f[i][2]
#     P1[int(ls_f[i][1])-1,int(ls_f[i][0])-1]=ls_f[i][2]
# p1=[]
# for i in range(N):
#     for j in range(N):
#         p1+=[P1[i][j]]
# p2=pyw('alf_400.pyw','probability:')[0]
# plt.figure()
# plt.plot(p1,p2,'.')
# plt.plot([0,0.25],[0,0.25])
# plt.show()

"""Coordinate Range"""
# lim=[]
# for i in range(100):
#     igro = f'D:\Biophysics\MyPython\\applications\\max_entr_gmx\\grofiles_rand\\1ubq_{i+1}.gro'
#     f = open(igro)
#     lsf = f.readlines()
#     f.close()
#     ls_f = []
#     for lf in lsf:
#         l_f = lf.strip('\n').split()
#         ls_f.append(l_f)
#     boundary = ls_f[len(ls_f) - 1]
#     x = []
#     y = []
#     z = []
#     for j in range(len(ls_f)):
#         if len(ls_f[j]) > 1 and ls_f[j][1] == 'CA':
#             x += [float(ls_f[j][3])]
#             y += [float(ls_f[j][4])]
#             z += [float(ls_f[j][5])]
#     lim.append([])
#     lim[i]+=[min(x),max(x),min(y),max(y),min(z),max(z)]
#
# x=np.linspace(1,100,100)
# plt.plot(x,np.array(lim)[:,0],label='xmin')
# plt.plot(x,np.array(lim)[:,1],label='xmax')
# plt.plot(x,np.array(lim)[:,2],label='ymin')
# plt.plot(x,np.array(lim)[:,3],label='ymax')
# plt.plot(x,np.array(lim)[:,4],label='zmin')
# plt.plot(x,np.array(lim)[:,5],label='zmax')
# plt.legend(loc='best')
# plt.show()

"""B Cell"""
# expfile='D:\\Biophysics\\MyPython\\applications\\b_cell\\cont_map\\exp_gcbc.dat'
# f=open(expfile)
# lsf=f.readlines()
# f.close()
# ls_f=[]
# for lf in lsf:
#     l_f=lf.strip('\n').split()
#     ls_f.append(l_f)
# ls_f=[list(map(float,sublist)) for sublist in ls_f]
# N=int(ls_f[len(ls_f)-1][0])
# P_exp=np.zeros((N,N),dtype=float)
# for j in range(len(ls_f)):
#     #if len(ls_f[i])>0: #In order to make sure the list index in next line does not exceed the range.
#     P_exp[int(ls_f[j][0])-1,int(ls_f[j][1])-1]=ls_f[j][2]
#     P_exp[int(ls_f[j][1])-1,int(ls_f[j][0])-1]=ls_f[j][2]
# pyw=open('b_cell_cont_map.pyw','w')
# pyw.write('The order of matrix: 76\n\n')
# pyw.write(('Contact Probability Map of All Monomers:\n'))
# for i in range(len(P_exp)):
#     for j in range(len(P_exp)):
#         pyw.write(f'{P_exp[i,j]}\n')
# pyw.close()

